<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>Line Segment Analyzer Public ver.</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 14px;
      color: #1f2933;
      box-sizing: border-box;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    *, *::before, *::after { box-sizing: inherit; }

    /* ------------- 冒頭の説明セクション ------------- */
    #introSection {
      padding: 14px 24px;  /* 縦の余白少し控えめ */
      border-bottom: 1px solid #111827;
      background: #111827; /* 黒に近いグレー */
    }

    #introInner {
      display: flex;
      align-items: flex-start;
      gap: 24px;
      /* 左寄せ（左パネルの真上に来るイメージ） */
    }

    #introText {
      flex: 1;
      min-width: 0;
      text-align: left;
      color: #e5e7eb;
    }

    #introBadge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 9px;
      border-radius: 999px;
      background-color: rgba(255, 255, 255, 0.10);
      color: #f9fafb;
      font-size: 11px;
      font-weight: 600;
      margin-bottom: 6px;
    }

    #introBadgeDot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background-color: #f9fafb;
    }

    /* 題目（日英一行） */
    #introTitle {
      margin: 0 0 8px;
      font-size: 22px;
      font-weight: 650;
      color: #ffffff;
    }

    #introText p {
      margin: 6px 0;
      line-height: 1.7;
      font-size: 13px;
      color: #e5e7eb;
      text-align: left;
    }

    #introText p strong {
      font-weight: 600;
      color: #ffffff;
    }

    /* ------------- サンプル画像の横スクロールエリア ------------- */
    #introImageWrapper {
      position: relative;
      flex: 0 0 380px;        /* 表示幅を少し広げる */
      background-color: #ffffff;
      border-radius: 14px;
      padding: 2px 32px;      /* ← 縦方向の余白をさらに狭く */
      box-shadow: 0 10px 20px rgba(15, 23, 42, 0.20);
      border: 1px solid #e5e7eb;
      overflow: hidden;
    }

    #introImageWrapper .introCarousel {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      padding-bottom: 2px;
      scroll-behavior: smooth;
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    #introImageWrapper .introCarousel::-webkit-scrollbar {
      display: none;
    }

    #introImageWrapper .introItem {
      flex: 0 0 auto;
      width: 300px;        /* 1枚あたりを少し広げる */
      text-align: center;
    }

    #introImageWrapper .introItem img {
      display: block;
      margin: 0 auto;
      height: 180px;       /* 高さを統一 */
      max-width: 100%;
      width: auto;
      border-radius: 10px;
      object-fit: contain;
      background-color: #f9fafb;
    }

    #introImageWrapper .introItem figcaption {
      margin-top: 4px;
      font-size: 11px;
      color: #4b5563;
      line-height: 1.5;
      letter-spacing: 0.01em;
    }

    .introNav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 22px;
      height: 32px;
      border: none;
      border-radius: 999px;
      background-color: rgba(17, 24, 39, 0.12);
      color: #f9fafb;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0;
      outline: none;
      transition: background-color 0.15s ease, transform 0.05s ease;
    }

    .introNav:hover {
      background-color: rgba(17, 24, 39, 0.22);
      transform: translateY(-50%) translateX(0);
    }

    .introNav:active {
      background-color: rgba(17, 24, 39, 0.30);
    }

    .introNav:focus-visible {
      outline: 2px solid #e5e7eb;
      outline-offset: 1px;
    }

    .introPrev { left: 6px; }
    .introNext { right: 6px; }

    /* ------------- 下部：ツール本体（左右2ペイン） ------------- */
    #appContainer {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    #leftPanel {
      width: clamp(340px, 38vw, 340px);
      padding: 10px;
      border-right: 1px solid #e5e7eb;
      overflow-y: auto;
      background-color: #f9fafb;
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    #leftPanel::-webkit-scrollbar {
      width: 0;
      height: 0;
    }

    #leftPanel h2 {
      margin: 0 0 8px;
      font-size: 15px;
      font-weight: 600;
      color: #111827;
      text-align: left;
    }

    #rightPanel {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 8px;
      overflow-y: auto;
      overflow-x: auto;
      background-color: #f3f4f6;
    }

    #topArea {
      display: flex;
      align-items: center;
      margin: 4px 0 4px;
      gap: 6px;
      color: #374151;
      font-size: 13px;
    }

    #canvasWrapper {
      width: 100%;
      max-width: 280px;
      margin: 4px auto 6px;
      display: block;
      overflow: visible;
      border-radius: 1px;
      background: #ffffff;
    }

    #canvas {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      display: block;
      border: 1px solid #d1d5db;
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.08);
      background-color: #ffffff;
    }

    #canvasHint {
      max-width: 280px;
      margin: 0 auto 6px;
      font-size: 11px;
      line-height: 1.4;
      color: #6b7280;
      text-align: left;
    }

    #result {
      flex: 1;
      border: 1px solid #d1d5db;
      padding: 1px;
      background-color: #ffffff;
      border-radius: 6px;
      font-size: 12px;
      color: #111827;
    }
 
    #thresholdPanel label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
      color: #374151;
      text-align: left;
    }

    /* ファイル選択 UI（日英併記カスタム） */
    #fileInputRow {
      margin: 6px 0 10px;
      font-size: 12px;
      color: #374151;
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    #fileInputLabel {
      font-weight: 500;
    }

    /* ネイティブの file input は視覚的に隠す（アクセシビリティ対応） */
    #imageInput {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    #fileSelectButton {
      display: inline-flex;
      align-items: center;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      background: linear-gradient(135deg, #2563eb, #4f46e5);
      color: #ffffff;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(37, 99, 235, 0.25);
      transition: transform 0.05s ease-out,
                  box-shadow 0.1s ease-out,
                  opacity 0.1s ease-out;
    }

    #fileSelectButton:hover {
      transform: translateY(-1px);
      box-shadow: 0 5px 12px rgba(37, 99, 235, 0.35);
      opacity: 0.96;
    }

    #fileSelectButton:active {
      transform: translateY(0);
      box-shadow: 0 2px 5px rgba(37, 99, 235, 0.30);
      opacity: 0.9;
    }

    #fileNameText {
      font-size: 11px;
      color: #6b7280;
    }


    #thresholdPanel input[type="number"] {
      margin-left: 4px;
      padding: 2px 4px;
      font-size: 12px;
      border-radius: 4px;
      border: 1px solid #d1d5db;
      width: 110px;
    }

    #thresholdPanel fieldset {
      margin-bottom: 10px;
      padding: 8px 10px 10px;
      border-radius: 10px;
      border: 1px solid #e5e7eb;
      background-color: #ffffff;
    }

    #thresholdPanel legend {
      font-weight: 600;
      font-size: 12px;
      color: #2563eb;
    }

    #reanalyzeBtn {
      margin-top: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, #2563eb, #4f46e5);
      color: #ffffff;
      font-size: 12px;
      font-weight: 500;
      box-shadow: 0 4px 10px rgba(37, 99, 235, 0.3);
      cursor: pointer;
      transition: transform 0.05s ease-out,
                  box-shadow 0.1s ease-out,
                  opacity 0.1s ease-out;
    }

    #reanalyzeBtn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 14px rgba(37, 99, 235, 0.4);
      opacity: 0.97;
    }

    #reanalyzeBtn:active {
      transform: translateY(0);
      box-shadow: 0 2px 6px rgba(37, 99, 235, 0.35);
      opacity: 0.9;
    }

    #reanalyzeStatus {
      margin-left: 8px;
      font-size: 12px;
      color: #006400;
    }

    table {
      border-collapse: collapse;
      font-size: 12px;
      table-layout: fixed;
      width: 100%;
    }

    th, td {
      border: 1px solid #ccc;
      padding: 2px 4px;
      text-align: right;
      vertical-align: top;
      word-wrap: break-word;
    }

    th.col-small, td.col-small { width: 50px; }

    th.col-canvas,
    td.col-canvas,
    th.col-obj-canvas,
    td.col-obj-canvas {
      /* 画像の幅に応じてセル幅が広がるようにする */
      white-space: nowrap;
    }

    td.col-canvas canvas,
    td.col-obj-canvas canvas {
      display: block;
      width: auto;
      height: auto;
      /* 必要であれば高さだけは制限しておく（任意） */
      max-height: 320px;
      margin: 0 auto;
    }

    th.col-abc, td.col-abc { width: 60px; }
    th.col-summary, td.col-summary { width: 100px; }

    #tableWrapper,
    #parallelTableWrapper,
    #intervalTableWrapper,
    #intervalGroupTableWrapper,
    #ratioTableWrapper,
    #ratioPatternTableWrapper {
      max-height: 450px;
      overflow-y: auto;
      overflow-x: auto;
      margin-bottom: 8px;
      border: 1px solid #ddd;
      background-color: #ffffff;
      overscroll-behavior-y: none;
    }

    #rightPanel { overscroll-behavior-y: none; }

    #tableWrapper table,
    #parallelTableWrapper table,
    #intervalTableWrapper table,
    #intervalGroupTableWrapper table,
    #ratioTableWrapper table,
    #ratioPatternTableWrapper table {
      width: max-content;
    }

    #tableWrapper thead th,
    #parallelTableWrapper thead th,
    #intervalTableWrapper thead th,
    #intervalGroupTableWrapper thead th,
    #ratioTableWrapper thead th,
    #ratioPatternTableWrapper thead th {
      position: sticky;
      top: 0;
      background: #f0f0f0;
      z-index: 2;
    }

    .hidden-row td:not(.keep-visible) { display: none; }

    button { cursor: pointer; }
  </style>
</head>

<body>
  <!-- ① 冒頭の説明ブロック -->
  <section id="introSection">
    <div id="introInner">
      <div id="introText">
        <!-- 題目：日英連続・同じ大きさ・太字 -->
        <h1 id="introTitle">線分解析ツール Line Segment Analyzer Public ver.</h1>

        <!-- 説明文：日英併記＋文毎に改行 -->
        <p>
                One’s "what it is" of things is grounded only in linguistic cognition, whereas one’s "what it must be"—the normative or aesthetic demand on laws, rules, and principles—is grounded only in ethical and aesthetic sense.
                Taken together, this bifurcation within all real beings presupposes the Creator who bears the authority to realize both "what it is" and "what it must be" for what is created.
                In terms of the concept of “must,” it is the common element of absoluteness, universality, invariance, eternity, purposiveness, lawfulness, essentiality, criteria of good and evil, criteria of life and death, criteria of existence or nonexistence, and criteria of beauty.
                <br>
                This tool analyzes why the positions, angles, and lengths of line segments in an image may be regarded as aesthetically meaningful.
                Regarding the essence of beauty, in the expression “it must be x,” both “it” and “x” can refer to anything, including even the negation of necessity or universality.
                Accordingly, the content of “what must be,” that is, the essence of beauty, cannot be defined by concrete objects, and its subjective variability makes physical quantification difficult.
                On the other hand, in physical configurations, it remains possible to examine whether there exists a “what it must be” in physical terms.
                This tool operationalizes such “must” through extensions, parallels, equal intervals, and ratios.
                It allows observation—across paintings, architecture, automobiles, and industrial products—of where artists or designers may have deliberately aligned lines.
        </p>
      </div>

      <!-- 横スクロール＋キャプション付きのサンプル画像一覧（◁ ▷ボタンあり） -->
      <div id="introImageWrapper">
        <button class="introNav introPrev" type="button" aria-label="Previous sample">◁</button>

        <div class="introCarousel">
          <figure class="introItem">
            <img
              src="img/Gogh_Wheat_Field_with_Cypresses_calculated.png"
              alt="MET open access Wheat Field with Cypresses の解析結果"
            />
            <figcaption>MET open access&nbsp;Wheat Field with Cypresses</figcaption>
          </figure>

          <figure class="introItem">
            <img
              src="img/Hokusai_Under_the_Wave_off_Kanagawa_calculated.png"
              alt="MET open access Under the Wave off Kanagawa の解析結果"
            />
            <figcaption>MET open access&nbsp;Under the Wave off Kanagawa</figcaption>
          </figure>

          <figure class="introItem">
            <img
              src="img/Road_Wagon_706_calculated.png"
              alt="MET open access Road Wagon の解析結果"
            />
            <figcaption>MET open access&nbsp;Road Wagon</figcaption>
          </figure>
        </div>

        <button class="introNav introNext" type="button" aria-label="Next sample">▷</button>
      </div>
    </div>
  </section>

  <!-- ② 下部：ツール本体 -->
  <div id="appContainer">
    <div id="leftPanel">
      <h2>閾値調整パネル / Threshold Panel</h2>

      <div id="topArea">
        <span>解析キャンバス / Analysis Canvas:</span>
      </div>

      <div id="canvasWrapper">
        <canvas id="canvas"></canvas>
      </div>

      <div id="canvasHint">
        範囲フィルタ編集 / Range Filter Editing:<br>
        ・節点の追加 … 赤線上をクリック<br>
         &nbsp;&nbsp;Add vertex … Click on the red line<br>
        ・節点の削除 … Ctrl + クリック（最小3点）<br>
        &nbsp;&nbsp;Delete vertex … Ctrl + Click (minimum 3)<br>
        ・ポリゴン全体の移動 … ポリゴン内側をドラッグ<br>
        &nbsp;&nbsp;Move whole polygon … Drag inside the polygon
      </div>

      <div id="fileInputRow">
        <span id="fileInputLabel">画像ファイル / Image file:</span>
        <label for="imageInput" id="fileSelectButton">
          ファイルを選択 / Choose file
        </label>
        <span id="fileNameText">
          選択されていません / No file selected
        </span>
        <input type="file" id="imageInput" accept="image/*">
      </div>

      <div id="thresholdPanel">
        <fieldset>
          <legend>線分抽出 / Line Extraction</legend>
          <label>
            最小線分長 (px) / Min line length (px):
            <input type="number" id="minLineLength" step="1" min="1" value="12">
          </label>
        </fieldset>

        <fieldset>
          <legend>延長（A/B/C 共通）/ Extension (A/B/C Shared)</legend>
          <label>
            orth 最大値（A/B/C 共通）/ Max orth (shared):
            <input type="number" id="extOrthCommon" step="0.1" min="0" value="5.0">
          </label>

          <input type="number" id="extAorth" step="0.1" value="5.0" style="display:none;">
          <input type="number" id="extBorth" step="0.1" value="5.0" style="display:none;">
          <input type="number" id="extCorth" step="0.1" value="5.0" style="display:none;">
        </fieldset>

        <fieldset>
          <legend>平行 閾値 / Parallel Thresholds</legend>
          <label>
            角度差しきい値 (deg) / Angle diff threshold (deg):
            <input type="number" id="parallelAngle" step="0.1" min="0" max="90" value="2.0">
          </label>
        </fieldset>

        <fieldset>
          <legend>同一間隔 閾値 / Equal-Interval Thresholds</legend>
          <label>
            間隔許容誤差 (px) / Interval EPS (px):
            <input type="number" id="intervalEps" step="0.1" min="0" value="1.0">
          </label>
        </fieldset>

        <fieldset>
          <legend>平行線比率 閾値 / Parallel-Ratio Thresholds</legend>
          <label>
            比率点距離許容誤差 (px) / Ratio point distance EPS (px):
            <input type="number" id="ratioPointEps" step="0.1" min="0" value="3.0">
          </label>
        </fieldset>

        <div>
          <button id="reanalyzeBtn">分析 / 再分析を実行 / Run analysis (apply thresholds)</button>
          <span id="reanalyzeStatus"></span>
        </div>
      </div>
    </div>

    <div id="rightPanel">
      <div id="result">
        OpenCV.js の初期化待ち、または画像を選択してから「分析 / 再分析を実行」ボタンを押すと、
        ここに分析結果が表示されます。<br>
        Waiting for OpenCV.js initialization. After selecting an image,
        press “Run analysis / re-analyze” to show the results here.
      </div>
    </div>
  </div>

  <!-- OpenCV.js -->
  <script src="libs/opencv.js"></script>
  <!-- ExcelJS -->
  <script src="https://cdn.jsdelivr.net/npm/exceljs/dist/exceljs.min.js"></script>
  <!-- 解析ロジック -->
  <script src="main.js"></script>

  <!-- orth 共通化のUIラッパ -->
  <script>
    (function () {
      function syncCommonOrthToHidden() {
        const common = document.getElementById("extOrthCommon");
        const a = document.getElementById("extAorth");
        const b = document.getElementById("extBorth");
        const c = document.getElementById("extCorth");
        if (!common || !a || !b || !c) return;

        const v = parseFloat(common.value);
        if (Number.isNaN(v)) return;

        a.value = v;
        b.value = v;
        c.value = v;
      }

      function initCommonOrthFromHidden() {
        const common = document.getElementById("extOrthCommon");
        const a = document.getElementById("extAorth");
        if (!common || !a) return;

        const v = parseFloat(a.value);
        if (!Number.isNaN(v)) common.value = v;
      }

      window.addEventListener("DOMContentLoaded", () => {
        initCommonOrthFromHidden();
        syncCommonOrthToHidden();

        if (typeof applyThresholdFromUI === "function") {
          applyThresholdFromUI();
        }

        const common = document.getElementById("extOrthCommon");
        if (common) {
          common.addEventListener("input", syncCommonOrthToHidden);
          common.addEventListener("change", syncCommonOrthToHidden);
        }
      });
    })();
  </script>

  <!-- サンプル画像カルーセル ◁ ▷ 操作用スクリプト（中央寄せ＋ループ方向維持） -->
  <script>
    (function () {
      function setupIntroCarousel() {
        const wrapper = document.getElementById("introImageWrapper");
        if (!wrapper) return;

        // 二重初期化防止（Modern Script Editor で複数回呼ばれる可能性対策）
        if (wrapper.dataset.carouselBound === "1") {
          return;
        }
        wrapper.dataset.carouselBound = "1";

        const carousel = wrapper.querySelector(".introCarousel");
        const prevBtn = wrapper.querySelector(".introPrev");
        const nextBtn = wrapper.querySelector(".introNext");
        if (!carousel || !prevBtn || !nextBtn) return;

        const originalItems = Array.from(carousel.querySelectorAll(".introItem"));
        const realCount = originalItems.length;
        if (!realCount) return;

        // 無限ループ用に先頭と末尾をクローン
        const firstClone = originalItems[0].cloneNode(true);
        const lastClone  = originalItems[realCount - 1].cloneNode(true);

        carousel.insertBefore(lastClone, originalItems[0]);
        carousel.appendChild(firstClone);

        const items = Array.from(carousel.querySelectorAll(".introItem"));
        const total = items.length;           // realCount + 2
        const firstRealIndex = 1;
        const lastRealIndex  = total - 2;
        const lastCloneIndex = total - 1;

        let currentIndex = firstRealIndex;

        // 中央寄せスクロール
        function centerOnItem(index, mode = "smooth") {
          if (index < 0) index = 0;
          if (index >= total) index = total - 1;
          currentIndex = index;

          const item = items[currentIndex];
          if (!item) return;

          const wrapperRect = wrapper.getBoundingClientRect();
          const itemRect    = item.getBoundingClientRect();

          const centerWrapper = wrapperRect.left + wrapperRect.width / 2;
          const centerItem    = itemRect.left + itemRect.width  / 2;

          const delta  = centerItem - centerWrapper;
          const target = carousel.scrollLeft + delta;

          if (mode === "instant") {
            // CSSの scroll-behavior: smooth を一時的に無効化して即座に移動
            const prevBehavior = carousel.style.scrollBehavior;
            carousel.style.scrollBehavior = "auto";
            carousel.scrollLeft = target;
            carousel.style.scrollBehavior = prevBehavior;
          } else {
            carousel.scrollTo({ left: target, behavior: "smooth" });
          }
        }

        // 初期位置：先頭の実アイテムを中央に
        centerOnItem(firstRealIndex, "instant");

        // ◁ ボタン
        prevBtn.addEventListener("click", () => {
          centerOnItem(currentIndex - 1, "smooth");

          // 左端クローンに到達した場合のみ、瞬時に右端の実アイテムへジャンプ
          setTimeout(() => {
            if (currentIndex === 0) {
              currentIndex = lastRealIndex;
              centerOnItem(currentIndex, "instant");
            }
          }, 350);
        });

        // ▷ ボタン
        nextBtn.addEventListener("click", () => {
          centerOnItem(currentIndex + 1, "smooth");

          // 右端クローンに到達した場合のみ、瞬時に左端の実アイテムへジャンプ
          setTimeout(() => {
            if (currentIndex === lastCloneIndex) {
              currentIndex = firstRealIndex;
              centerOnItem(currentIndex, "instant");
            }
          }, 350);
        });
      }

      // DOM の状態に応じて、即時 or DOMContentLoaded 待ちで初期化
      if (document.readyState === "loading") {
        window.addEventListener("DOMContentLoaded", setupIntroCarousel);
      } else {
        setupIntroCarousel();
      }
    })();
  </script>
</body>
</html>
